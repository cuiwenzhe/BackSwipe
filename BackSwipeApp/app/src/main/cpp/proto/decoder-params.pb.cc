// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: decoder-params.proto

#include "decoder-params.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_decoder_2dparams_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GestureSpatialParams_decoder_2dparams_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decoder_2dparams_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TapSpatialParams_decoder_2dparams_2eproto;
namespace proto {
class GestureSpatialParamsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GestureSpatialParams> _instance;
} _GestureSpatialParams_default_instance_;
class TapSpatialParamsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TapSpatialParams> _instance;
} _TapSpatialParams_default_instance_;
class DecoderParamsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DecoderParams> _instance;
} _DecoderParams_default_instance_;
}  // namespace proto
static void InitDefaultsscc_info_DecoderParams_decoder_2dparams_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::_DecoderParams_default_instance_;
    new (ptr) ::proto::DecoderParams();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::DecoderParams::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_DecoderParams_decoder_2dparams_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_DecoderParams_decoder_2dparams_2eproto}, {
      &scc_info_GestureSpatialParams_decoder_2dparams_2eproto.base,
      &scc_info_TapSpatialParams_decoder_2dparams_2eproto.base,}};

static void InitDefaultsscc_info_GestureSpatialParams_decoder_2dparams_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::_GestureSpatialParams_default_instance_;
    new (ptr) ::proto::GestureSpatialParams();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::GestureSpatialParams::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GestureSpatialParams_decoder_2dparams_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GestureSpatialParams_decoder_2dparams_2eproto}, {}};

static void InitDefaultsscc_info_TapSpatialParams_decoder_2dparams_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::_TapSpatialParams_default_instance_;
    new (ptr) ::proto::TapSpatialParams();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::TapSpatialParams::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TapSpatialParams_decoder_2dparams_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TapSpatialParams_decoder_2dparams_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_decoder_2dparams_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_decoder_2dparams_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_decoder_2dparams_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_decoder_2dparams_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, key_error_sigma_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, direction_error_sigma_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, skip_pause_score_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, skip_corner_score_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, precise_match_threshold_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, max_imprecise_match_penalty_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, min_curvature_for_corner_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, pause_duration_in_millis_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, endpoint_offset_for_maxima_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, min_align_key_score_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, completion_score_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, first_point_weight_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, allow_multi_term_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, use_space_for_multi_term_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, min_space_align_score_),
  PROTOBUF_FIELD_OFFSET(::proto::GestureSpatialParams, extra_term_score_),
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, key_error_sigma_),
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, non_literal_match_penalty_),
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, omission_score_),
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, omission_skippable_score_),
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, insertion_score_),
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, substitution_score_),
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, min_align_key_score_),
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, completion_score_),
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, allow_multi_term_),
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, extra_term_score_),
  PROTOBUF_FIELD_OFFSET(::proto::TapSpatialParams, space_to_nonspace_correction_score_),
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  0,
  10,
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, sample_distance_in_key_widths_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, active_beam_width_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, prefix_beam_width_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, token_pool_capacity_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, num_suggestions_to_return_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, score_to_beat_offset_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, score_to_beat_offset_for_corrections_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, prefix_lm_weight_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, lexicon_unigram_backoff_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, gesture_params_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, tap_params_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, max_multi_term_terminals_),
  PROTOBUF_FIELD_OFFSET(::proto::DecoderParams, score_to_beat_absolute_),
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  0,
  1,
  12,
  2,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 21, sizeof(::proto::GestureSpatialParams)},
  { 37, 53, sizeof(::proto::TapSpatialParams)},
  { 64, 82, sizeof(::proto::DecoderParams)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::proto::_GestureSpatialParams_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::proto::_TapSpatialParams_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::proto::_DecoderParams_default_instance_),
};

const char descriptor_table_protodef_decoder_2dparams_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\024decoder-params.proto\022\005proto\"\305\004\n\024Gestur"
  "eSpatialParams\022\034\n\017key_error_sigma\030\001 \001(\002:"
  "\0030.9\022\"\n\025direction_error_sigma\030\002 \001(\002:\0030.7"
  "\022\034\n\020skip_pause_score\030\003 \001(\002:\002-2\022\035\n\021skip_c"
  "orner_score\030\004 \001(\002:\002-4\022#\n\027precise_match_t"
  "hreshold\030\006 \001(\002:\002-2\022\'\n\033max_imprecise_matc"
  "h_penalty\030\007 \001(\002:\002-4\022*\n\030min_curvature_for"
  "_corner\030\n \001(\002:\0100.392699\022%\n\030pause_duratio"
  "n_in_millis\030\013 \001(\002:\003200\022%\n\032endpoint_offse"
  "t_for_maxima\030\014 \001(\002:\0012\022\037\n\023min_align_key_s"
  "core\030\r \001(\002:\002-8\022\034\n\020completion_score\030\016 \001(\002"
  ":\002-4\022\035\n\022first_point_weight\030\017 \001(\002:\0012\022\037\n\020a"
  "llow_multi_term\030\020 \001(\010:\005false\022\'\n\030use_spac"
  "e_for_multi_term\030\021 \001(\010:\005false\022!\n\025min_spa"
  "ce_align_score\030\022 \001(\002:\002-1\022\033\n\020extra_term_s"
  "core\030\023 \001(\002:\0010\"\204\003\n\020TapSpatialParams\022\034\n\017ke"
  "y_error_sigma\030\001 \001(\002:\0030.7\022%\n\031non_literal_"
  "match_penalty\030\002 \001(\002:\002-4\022\032\n\016omission_scor"
  "e\030\003 \001(\002:\002-5\022&\n\030omission_skippable_score\030"
  "\004 \001(\002:\004-0.5\022\033\n\017insertion_score\030\005 \001(\002:\002-8"
  "\022\036\n\022substitution_score\030\006 \001(\002:\002-8\022\037\n\023min_"
  "align_key_score\030\007 \001(\002:\002-8\022\034\n\020completion_"
  "score\030\010 \001(\002:\002-2\022\036\n\020allow_multi_term\030\t \001("
  "\010:\004true\022\033\n\020extra_term_score\030\n \001(\002:\0010\022.\n\""
  "space_to_nonspace_correction_score\030\013 \001(\002"
  ":\002-8\"\213\004\n\rDecoderParams\022+\n\035sample_distanc"
  "e_in_key_widths\030\001 \001(\002:\0040.25\022\036\n\021active_be"
  "am_width\030\002 \001(\005:\003100\022\034\n\021prefix_beam_width"
  "\030\003 \001(\005:\0013\022!\n\023token_pool_capacity\030\004 \001(\005:\004"
  "1000\022%\n\031num_suggestions_to_return\030\005 \001(\005:"
  "\00220\022!\n\024score_to_beat_offset\030\006 \001(\002:\003-12\0220"
  "\n$score_to_beat_offset_for_corrections\030\007"
  " \001(\002:\002-6\022\035\n\020prefix_lm_weight\030\010 \001(\002:\0030.5\022"
  "#\n\027lexicon_unigram_backoff\030\t \001(\002:\002-5\0223\n\016"
  "gesture_params\030\n \001(\0132\033.proto.GestureSpat"
  "ialParams\022+\n\ntap_params\030\013 \001(\0132\027.proto.Ta"
  "pSpatialParams\022$\n\030max_multi_term_termina"
  "ls\030\014 \001(\005:\00210\022$\n\026score_to_beat_absolute\030\r"
  " \001(\002:\004-inf"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_decoder_2dparams_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_decoder_2dparams_2eproto_sccs[3] = {
  &scc_info_DecoderParams_decoder_2dparams_2eproto.base,
  &scc_info_GestureSpatialParams_decoder_2dparams_2eproto.base,
  &scc_info_TapSpatialParams_decoder_2dparams_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_decoder_2dparams_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_decoder_2dparams_2eproto = {
  false, false, descriptor_table_protodef_decoder_2dparams_2eproto, "decoder-params.proto", 1530,
  &descriptor_table_decoder_2dparams_2eproto_once, descriptor_table_decoder_2dparams_2eproto_sccs, descriptor_table_decoder_2dparams_2eproto_deps, 3, 0,
  schemas, file_default_instances, TableStruct_decoder_2dparams_2eproto::offsets,
  file_level_metadata_decoder_2dparams_2eproto, 3, file_level_enum_descriptors_decoder_2dparams_2eproto, file_level_service_descriptors_decoder_2dparams_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_decoder_2dparams_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_decoder_2dparams_2eproto)), true);
namespace proto {

// ===================================================================

void GestureSpatialParams::InitAsDefaultInstance() {
}
class GestureSpatialParams::_Internal {
 public:
  using HasBits = decltype(std::declval<GestureSpatialParams>()._has_bits_);
  static void set_has_key_error_sigma(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_direction_error_sigma(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_skip_pause_score(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_skip_corner_score(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_precise_match_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_max_imprecise_match_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_min_curvature_for_corner(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_pause_duration_in_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_endpoint_offset_for_maxima(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_min_align_key_score(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_completion_score(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_first_point_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_allow_multi_term(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_use_space_for_multi_term(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_space_align_score(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_extra_term_score(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GestureSpatialParams::GestureSpatialParams(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:proto.GestureSpatialParams)
}
GestureSpatialParams::GestureSpatialParams(const GestureSpatialParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&allow_multi_term_, &from.allow_multi_term_,
    static_cast<size_t>(reinterpret_cast<char*>(&first_point_weight_) -
    reinterpret_cast<char*>(&allow_multi_term_)) + sizeof(first_point_weight_));
  // @@protoc_insertion_point(copy_constructor:proto.GestureSpatialParams)
}

void GestureSpatialParams::SharedCtor() {
  ::memset(&allow_multi_term_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&extra_term_score_) -
      reinterpret_cast<char*>(&allow_multi_term_)) + sizeof(extra_term_score_));
  min_space_align_score_ = -1;
  key_error_sigma_ = 0.9f;
  direction_error_sigma_ = 0.7f;
  skip_pause_score_ = -2;
  skip_corner_score_ = -4;
  precise_match_threshold_ = -2;
  max_imprecise_match_penalty_ = -4;
  min_curvature_for_corner_ = 0.392699f;
  pause_duration_in_millis_ = 200;
  endpoint_offset_for_maxima_ = 2;
  min_align_key_score_ = -8;
  completion_score_ = -4;
  first_point_weight_ = 2;
}

GestureSpatialParams::~GestureSpatialParams() {
  // @@protoc_insertion_point(destructor:proto.GestureSpatialParams)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GestureSpatialParams::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void GestureSpatialParams::ArenaDtor(void* object) {
  GestureSpatialParams* _this = reinterpret_cast< GestureSpatialParams* >(object);
  (void)_this;
}
void GestureSpatialParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GestureSpatialParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GestureSpatialParams& GestureSpatialParams::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GestureSpatialParams_decoder_2dparams_2eproto.base);
  return *internal_default_instance();
}


void GestureSpatialParams::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.GestureSpatialParams)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&allow_multi_term_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&extra_term_score_) -
        reinterpret_cast<char*>(&allow_multi_term_)) + sizeof(extra_term_score_));
    min_space_align_score_ = -1;
    key_error_sigma_ = 0.9f;
    direction_error_sigma_ = 0.7f;
    skip_pause_score_ = -2;
    skip_corner_score_ = -4;
  }
  if (cached_has_bits & 0x0000ff00u) {
    precise_match_threshold_ = -2;
    max_imprecise_match_penalty_ = -4;
    min_curvature_for_corner_ = 0.392699f;
    pause_duration_in_millis_ = 200;
    endpoint_offset_for_maxima_ = 2;
    min_align_key_score_ = -8;
    completion_score_ = -4;
    first_point_weight_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GestureSpatialParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float key_error_sigma = 1 [default = 0.9];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_key_error_sigma(&has_bits);
          key_error_sigma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float direction_error_sigma = 2 [default = 0.7];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_direction_error_sigma(&has_bits);
          direction_error_sigma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float skip_pause_score = 3 [default = -2];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_skip_pause_score(&has_bits);
          skip_pause_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float skip_corner_score = 4 [default = -4];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_skip_corner_score(&has_bits);
          skip_corner_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float precise_match_threshold = 6 [default = -2];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_precise_match_threshold(&has_bits);
          precise_match_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float max_imprecise_match_penalty = 7 [default = -4];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_max_imprecise_match_penalty(&has_bits);
          max_imprecise_match_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float min_curvature_for_corner = 10 [default = 0.392699];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_min_curvature_for_corner(&has_bits);
          min_curvature_for_corner_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float pause_duration_in_millis = 11 [default = 200];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          _Internal::set_has_pause_duration_in_millis(&has_bits);
          pause_duration_in_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float endpoint_offset_for_maxima = 12 [default = 2];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 101)) {
          _Internal::set_has_endpoint_offset_for_maxima(&has_bits);
          endpoint_offset_for_maxima_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float min_align_key_score = 13 [default = -8];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 109)) {
          _Internal::set_has_min_align_key_score(&has_bits);
          min_align_key_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float completion_score = 14 [default = -4];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 117)) {
          _Internal::set_has_completion_score(&has_bits);
          completion_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float first_point_weight = 15 [default = 2];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 125)) {
          _Internal::set_has_first_point_weight(&has_bits);
          first_point_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool allow_multi_term = 16 [default = false];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_allow_multi_term(&has_bits);
          allow_multi_term_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_space_for_multi_term = 17 [default = false];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_use_space_for_multi_term(&has_bits);
          use_space_for_multi_term_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float min_space_align_score = 18 [default = -1];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 149)) {
          _Internal::set_has_min_space_align_score(&has_bits);
          min_space_align_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float extra_term_score = 19 [default = 0];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 157)) {
          _Internal::set_has_extra_term_score(&has_bits);
          extra_term_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GestureSpatialParams::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.GestureSpatialParams)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float key_error_sigma = 1 [default = 0.9];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_key_error_sigma(), target);
  }

  // optional float direction_error_sigma = 2 [default = 0.7];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_direction_error_sigma(), target);
  }

  // optional float skip_pause_score = 3 [default = -2];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_skip_pause_score(), target);
  }

  // optional float skip_corner_score = 4 [default = -4];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_skip_corner_score(), target);
  }

  // optional float precise_match_threshold = 6 [default = -2];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_precise_match_threshold(), target);
  }

  // optional float max_imprecise_match_penalty = 7 [default = -4];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_max_imprecise_match_penalty(), target);
  }

  // optional float min_curvature_for_corner = 10 [default = 0.392699];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_min_curvature_for_corner(), target);
  }

  // optional float pause_duration_in_millis = 11 [default = 200];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_pause_duration_in_millis(), target);
  }

  // optional float endpoint_offset_for_maxima = 12 [default = 2];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->_internal_endpoint_offset_for_maxima(), target);
  }

  // optional float min_align_key_score = 13 [default = -8];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(13, this->_internal_min_align_key_score(), target);
  }

  // optional float completion_score = 14 [default = -4];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_completion_score(), target);
  }

  // optional float first_point_weight = 15 [default = 2];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_first_point_weight(), target);
  }

  // optional bool allow_multi_term = 16 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_allow_multi_term(), target);
  }

  // optional bool use_space_for_multi_term = 17 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_use_space_for_multi_term(), target);
  }

  // optional float min_space_align_score = 18 [default = -1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(18, this->_internal_min_space_align_score(), target);
  }

  // optional float extra_term_score = 19 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(19, this->_internal_extra_term_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.GestureSpatialParams)
  return target;
}

size_t GestureSpatialParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.GestureSpatialParams)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool allow_multi_term = 16 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional bool use_space_for_multi_term = 17 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 1;
    }

    // optional float extra_term_score = 19 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 4;
    }

    // optional float min_space_align_score = 18 [default = -1];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 4;
    }

    // optional float key_error_sigma = 1 [default = 0.9];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float direction_error_sigma = 2 [default = 0.7];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float skip_pause_score = 3 [default = -2];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float skip_corner_score = 4 [default = -4];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float precise_match_threshold = 6 [default = -2];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float max_imprecise_match_penalty = 7 [default = -4];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float min_curvature_for_corner = 10 [default = 0.392699];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float pause_duration_in_millis = 11 [default = 200];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float endpoint_offset_for_maxima = 12 [default = 2];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float min_align_key_score = 13 [default = -8];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional float completion_score = 14 [default = -4];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional float first_point_weight = 15 [default = 2];
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GestureSpatialParams::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.GestureSpatialParams)
  GOOGLE_DCHECK_NE(&from, this);
  const GestureSpatialParams* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GestureSpatialParams>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.GestureSpatialParams)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.GestureSpatialParams)
    MergeFrom(*source);
  }
}

void GestureSpatialParams::MergeFrom(const GestureSpatialParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.GestureSpatialParams)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      allow_multi_term_ = from.allow_multi_term_;
    }
    if (cached_has_bits & 0x00000002u) {
      use_space_for_multi_term_ = from.use_space_for_multi_term_;
    }
    if (cached_has_bits & 0x00000004u) {
      extra_term_score_ = from.extra_term_score_;
    }
    if (cached_has_bits & 0x00000008u) {
      min_space_align_score_ = from.min_space_align_score_;
    }
    if (cached_has_bits & 0x00000010u) {
      key_error_sigma_ = from.key_error_sigma_;
    }
    if (cached_has_bits & 0x00000020u) {
      direction_error_sigma_ = from.direction_error_sigma_;
    }
    if (cached_has_bits & 0x00000040u) {
      skip_pause_score_ = from.skip_pause_score_;
    }
    if (cached_has_bits & 0x00000080u) {
      skip_corner_score_ = from.skip_corner_score_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      precise_match_threshold_ = from.precise_match_threshold_;
    }
    if (cached_has_bits & 0x00000200u) {
      max_imprecise_match_penalty_ = from.max_imprecise_match_penalty_;
    }
    if (cached_has_bits & 0x00000400u) {
      min_curvature_for_corner_ = from.min_curvature_for_corner_;
    }
    if (cached_has_bits & 0x00000800u) {
      pause_duration_in_millis_ = from.pause_duration_in_millis_;
    }
    if (cached_has_bits & 0x00001000u) {
      endpoint_offset_for_maxima_ = from.endpoint_offset_for_maxima_;
    }
    if (cached_has_bits & 0x00002000u) {
      min_align_key_score_ = from.min_align_key_score_;
    }
    if (cached_has_bits & 0x00004000u) {
      completion_score_ = from.completion_score_;
    }
    if (cached_has_bits & 0x00008000u) {
      first_point_weight_ = from.first_point_weight_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GestureSpatialParams::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.GestureSpatialParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GestureSpatialParams::CopyFrom(const GestureSpatialParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.GestureSpatialParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GestureSpatialParams::IsInitialized() const {
  return true;
}

void GestureSpatialParams::InternalSwap(GestureSpatialParams* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GestureSpatialParams, extra_term_score_)
      + sizeof(GestureSpatialParams::extra_term_score_)
      - PROTOBUF_FIELD_OFFSET(GestureSpatialParams, allow_multi_term_)>(
          reinterpret_cast<char*>(&allow_multi_term_),
          reinterpret_cast<char*>(&other->allow_multi_term_));
  swap(min_space_align_score_, other->min_space_align_score_);
  swap(key_error_sigma_, other->key_error_sigma_);
  swap(direction_error_sigma_, other->direction_error_sigma_);
  swap(skip_pause_score_, other->skip_pause_score_);
  swap(skip_corner_score_, other->skip_corner_score_);
  swap(precise_match_threshold_, other->precise_match_threshold_);
  swap(max_imprecise_match_penalty_, other->max_imprecise_match_penalty_);
  swap(min_curvature_for_corner_, other->min_curvature_for_corner_);
  swap(pause_duration_in_millis_, other->pause_duration_in_millis_);
  swap(endpoint_offset_for_maxima_, other->endpoint_offset_for_maxima_);
  swap(min_align_key_score_, other->min_align_key_score_);
  swap(completion_score_, other->completion_score_);
  swap(first_point_weight_, other->first_point_weight_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GestureSpatialParams::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TapSpatialParams::InitAsDefaultInstance() {
}
class TapSpatialParams::_Internal {
 public:
  using HasBits = decltype(std::declval<TapSpatialParams>()._has_bits_);
  static void set_has_key_error_sigma(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_non_literal_match_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_omission_score(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_omission_skippable_score(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_insertion_score(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_substitution_score(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_min_align_key_score(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_completion_score(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_allow_multi_term(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_extra_term_score(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_space_to_nonspace_correction_score(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

TapSpatialParams::TapSpatialParams(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:proto.TapSpatialParams)
}
TapSpatialParams::TapSpatialParams(const TapSpatialParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&extra_term_score_, &from.extra_term_score_,
    static_cast<size_t>(reinterpret_cast<char*>(&space_to_nonspace_correction_score_) -
    reinterpret_cast<char*>(&extra_term_score_)) + sizeof(space_to_nonspace_correction_score_));
  // @@protoc_insertion_point(copy_constructor:proto.TapSpatialParams)
}

void TapSpatialParams::SharedCtor() {
  extra_term_score_ = 0;
  key_error_sigma_ = 0.7f;
  non_literal_match_penalty_ = -4;
  omission_score_ = -5;
  omission_skippable_score_ = -0.5f;
  insertion_score_ = -8;
  substitution_score_ = -8;
  min_align_key_score_ = -8;
  completion_score_ = -2;
  allow_multi_term_ = true;
  space_to_nonspace_correction_score_ = -8;
}

TapSpatialParams::~TapSpatialParams() {
  // @@protoc_insertion_point(destructor:proto.TapSpatialParams)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TapSpatialParams::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TapSpatialParams::ArenaDtor(void* object) {
  TapSpatialParams* _this = reinterpret_cast< TapSpatialParams* >(object);
  (void)_this;
}
void TapSpatialParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TapSpatialParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TapSpatialParams& TapSpatialParams::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TapSpatialParams_decoder_2dparams_2eproto.base);
  return *internal_default_instance();
}


void TapSpatialParams::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TapSpatialParams)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    extra_term_score_ = 0;
    key_error_sigma_ = 0.7f;
    non_literal_match_penalty_ = -4;
    omission_score_ = -5;
    omission_skippable_score_ = -0.5f;
    insertion_score_ = -8;
    substitution_score_ = -8;
    min_align_key_score_ = -8;
  }
  if (cached_has_bits & 0x00000700u) {
    completion_score_ = -2;
    allow_multi_term_ = true;
    space_to_nonspace_correction_score_ = -8;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TapSpatialParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float key_error_sigma = 1 [default = 0.7];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_key_error_sigma(&has_bits);
          key_error_sigma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float non_literal_match_penalty = 2 [default = -4];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_non_literal_match_penalty(&has_bits);
          non_literal_match_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float omission_score = 3 [default = -5];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_omission_score(&has_bits);
          omission_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float omission_skippable_score = 4 [default = -0.5];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_omission_skippable_score(&has_bits);
          omission_skippable_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float insertion_score = 5 [default = -8];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_insertion_score(&has_bits);
          insertion_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float substitution_score = 6 [default = -8];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_substitution_score(&has_bits);
          substitution_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float min_align_key_score = 7 [default = -8];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_min_align_key_score(&has_bits);
          min_align_key_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float completion_score = 8 [default = -2];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_completion_score(&has_bits);
          completion_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool allow_multi_term = 9 [default = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_allow_multi_term(&has_bits);
          allow_multi_term_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float extra_term_score = 10 [default = 0];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_extra_term_score(&has_bits);
          extra_term_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float space_to_nonspace_correction_score = 11 [default = -8];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          _Internal::set_has_space_to_nonspace_correction_score(&has_bits);
          space_to_nonspace_correction_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TapSpatialParams::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TapSpatialParams)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float key_error_sigma = 1 [default = 0.7];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_key_error_sigma(), target);
  }

  // optional float non_literal_match_penalty = 2 [default = -4];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_non_literal_match_penalty(), target);
  }

  // optional float omission_score = 3 [default = -5];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_omission_score(), target);
  }

  // optional float omission_skippable_score = 4 [default = -0.5];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_omission_skippable_score(), target);
  }

  // optional float insertion_score = 5 [default = -8];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_insertion_score(), target);
  }

  // optional float substitution_score = 6 [default = -8];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_substitution_score(), target);
  }

  // optional float min_align_key_score = 7 [default = -8];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_min_align_key_score(), target);
  }

  // optional float completion_score = 8 [default = -2];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_completion_score(), target);
  }

  // optional bool allow_multi_term = 9 [default = true];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_allow_multi_term(), target);
  }

  // optional float extra_term_score = 10 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_extra_term_score(), target);
  }

  // optional float space_to_nonspace_correction_score = 11 [default = -8];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_space_to_nonspace_correction_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TapSpatialParams)
  return target;
}

size_t TapSpatialParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TapSpatialParams)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float extra_term_score = 10 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float key_error_sigma = 1 [default = 0.7];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float non_literal_match_penalty = 2 [default = -4];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float omission_score = 3 [default = -5];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float omission_skippable_score = 4 [default = -0.5];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float insertion_score = 5 [default = -8];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float substitution_score = 6 [default = -8];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float min_align_key_score = 7 [default = -8];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional float completion_score = 8 [default = -2];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional bool allow_multi_term = 9 [default = true];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional float space_to_nonspace_correction_score = 11 [default = -8];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TapSpatialParams::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.TapSpatialParams)
  GOOGLE_DCHECK_NE(&from, this);
  const TapSpatialParams* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TapSpatialParams>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.TapSpatialParams)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.TapSpatialParams)
    MergeFrom(*source);
  }
}

void TapSpatialParams::MergeFrom(const TapSpatialParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.TapSpatialParams)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      extra_term_score_ = from.extra_term_score_;
    }
    if (cached_has_bits & 0x00000002u) {
      key_error_sigma_ = from.key_error_sigma_;
    }
    if (cached_has_bits & 0x00000004u) {
      non_literal_match_penalty_ = from.non_literal_match_penalty_;
    }
    if (cached_has_bits & 0x00000008u) {
      omission_score_ = from.omission_score_;
    }
    if (cached_has_bits & 0x00000010u) {
      omission_skippable_score_ = from.omission_skippable_score_;
    }
    if (cached_has_bits & 0x00000020u) {
      insertion_score_ = from.insertion_score_;
    }
    if (cached_has_bits & 0x00000040u) {
      substitution_score_ = from.substitution_score_;
    }
    if (cached_has_bits & 0x00000080u) {
      min_align_key_score_ = from.min_align_key_score_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      completion_score_ = from.completion_score_;
    }
    if (cached_has_bits & 0x00000200u) {
      allow_multi_term_ = from.allow_multi_term_;
    }
    if (cached_has_bits & 0x00000400u) {
      space_to_nonspace_correction_score_ = from.space_to_nonspace_correction_score_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TapSpatialParams::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.TapSpatialParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TapSpatialParams::CopyFrom(const TapSpatialParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TapSpatialParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TapSpatialParams::IsInitialized() const {
  return true;
}

void TapSpatialParams::InternalSwap(TapSpatialParams* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(extra_term_score_, other->extra_term_score_);
  swap(key_error_sigma_, other->key_error_sigma_);
  swap(non_literal_match_penalty_, other->non_literal_match_penalty_);
  swap(omission_score_, other->omission_score_);
  swap(omission_skippable_score_, other->omission_skippable_score_);
  swap(insertion_score_, other->insertion_score_);
  swap(substitution_score_, other->substitution_score_);
  swap(min_align_key_score_, other->min_align_key_score_);
  swap(completion_score_, other->completion_score_);
  swap(allow_multi_term_, other->allow_multi_term_);
  swap(space_to_nonspace_correction_score_, other->space_to_nonspace_correction_score_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TapSpatialParams::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void DecoderParams::InitAsDefaultInstance() {
  ::proto::_DecoderParams_default_instance_._instance.get_mutable()->gesture_params_ = const_cast< ::proto::GestureSpatialParams*>(
      ::proto::GestureSpatialParams::internal_default_instance());
  ::proto::_DecoderParams_default_instance_._instance.get_mutable()->tap_params_ = const_cast< ::proto::TapSpatialParams*>(
      ::proto::TapSpatialParams::internal_default_instance());
}
class DecoderParams::_Internal {
 public:
  using HasBits = decltype(std::declval<DecoderParams>()._has_bits_);
  static void set_has_sample_distance_in_key_widths(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_active_beam_width(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_prefix_beam_width(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_token_pool_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_num_suggestions_to_return(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_score_to_beat_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_score_to_beat_offset_for_corrections(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_prefix_lm_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_lexicon_unigram_backoff(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::proto::GestureSpatialParams& gesture_params(const DecoderParams* msg);
  static void set_has_gesture_params(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::proto::TapSpatialParams& tap_params(const DecoderParams* msg);
  static void set_has_tap_params(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_multi_term_terminals(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_score_to_beat_absolute(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::proto::GestureSpatialParams&
DecoderParams::_Internal::gesture_params(const DecoderParams* msg) {
  return *msg->gesture_params_;
}
const ::proto::TapSpatialParams&
DecoderParams::_Internal::tap_params(const DecoderParams* msg) {
  return *msg->tap_params_;
}
DecoderParams::DecoderParams(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:proto.DecoderParams)
}
DecoderParams::DecoderParams(const DecoderParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_gesture_params()) {
    gesture_params_ = new ::proto::GestureSpatialParams(*from.gesture_params_);
  } else {
    gesture_params_ = nullptr;
  }
  if (from._internal_has_tap_params()) {
    tap_params_ = new ::proto::TapSpatialParams(*from.tap_params_);
  } else {
    tap_params_ = nullptr;
  }
  ::memcpy(&score_to_beat_absolute_, &from.score_to_beat_absolute_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_multi_term_terminals_) -
    reinterpret_cast<char*>(&score_to_beat_absolute_)) + sizeof(max_multi_term_terminals_));
  // @@protoc_insertion_point(copy_constructor:proto.DecoderParams)
}

void DecoderParams::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DecoderParams_decoder_2dparams_2eproto.base);
  ::memset(&gesture_params_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tap_params_) -
      reinterpret_cast<char*>(&gesture_params_)) + sizeof(tap_params_));
  score_to_beat_absolute_ = -std::numeric_limits<float>::infinity();
  sample_distance_in_key_widths_ = 0.25f;
  active_beam_width_ = 100;
  prefix_beam_width_ = 3;
  token_pool_capacity_ = 1000;
  num_suggestions_to_return_ = 20;
  score_to_beat_offset_ = -12;
  score_to_beat_offset_for_corrections_ = -6;
  prefix_lm_weight_ = 0.5f;
  lexicon_unigram_backoff_ = -5;
  max_multi_term_terminals_ = 10;
}

DecoderParams::~DecoderParams() {
  // @@protoc_insertion_point(destructor:proto.DecoderParams)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void DecoderParams::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete gesture_params_;
  if (this != internal_default_instance()) delete tap_params_;
}

void DecoderParams::ArenaDtor(void* object) {
  DecoderParams* _this = reinterpret_cast< DecoderParams* >(object);
  (void)_this;
}
void DecoderParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DecoderParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DecoderParams& DecoderParams::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DecoderParams_decoder_2dparams_2eproto.base);
  return *internal_default_instance();
}


void DecoderParams::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.DecoderParams)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(gesture_params_ != nullptr);
      gesture_params_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(tap_params_ != nullptr);
      tap_params_->Clear();
    }
    score_to_beat_absolute_ = -std::numeric_limits<float>::infinity();
    sample_distance_in_key_widths_ = 0.25f;
    active_beam_width_ = 100;
    prefix_beam_width_ = 3;
    token_pool_capacity_ = 1000;
    num_suggestions_to_return_ = 20;
  }
  if (cached_has_bits & 0x00001f00u) {
    score_to_beat_offset_ = -12;
    score_to_beat_offset_for_corrections_ = -6;
    prefix_lm_weight_ = 0.5f;
    lexicon_unigram_backoff_ = -5;
    max_multi_term_terminals_ = 10;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DecoderParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float sample_distance_in_key_widths = 1 [default = 0.25];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_sample_distance_in_key_widths(&has_bits);
          sample_distance_in_key_widths_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 active_beam_width = 2 [default = 100];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_active_beam_width(&has_bits);
          active_beam_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 prefix_beam_width = 3 [default = 3];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_prefix_beam_width(&has_bits);
          prefix_beam_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 token_pool_capacity = 4 [default = 1000];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_token_pool_capacity(&has_bits);
          token_pool_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_suggestions_to_return = 5 [default = 20];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_num_suggestions_to_return(&has_bits);
          num_suggestions_to_return_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float score_to_beat_offset = 6 [default = -12];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_score_to_beat_offset(&has_bits);
          score_to_beat_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float score_to_beat_offset_for_corrections = 7 [default = -6];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_score_to_beat_offset_for_corrections(&has_bits);
          score_to_beat_offset_for_corrections_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float prefix_lm_weight = 8 [default = 0.5];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_prefix_lm_weight(&has_bits);
          prefix_lm_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float lexicon_unigram_backoff = 9 [default = -5];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_lexicon_unigram_backoff(&has_bits);
          lexicon_unigram_backoff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .proto.GestureSpatialParams gesture_params = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_gesture_params(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .proto.TapSpatialParams tap_params = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_tap_params(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_multi_term_terminals = 12 [default = 10];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_max_multi_term_terminals(&has_bits);
          max_multi_term_terminals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float score_to_beat_absolute = 13 [default = -inf];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 109)) {
          _Internal::set_has_score_to_beat_absolute(&has_bits);
          score_to_beat_absolute_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DecoderParams::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.DecoderParams)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float sample_distance_in_key_widths = 1 [default = 0.25];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_sample_distance_in_key_widths(), target);
  }

  // optional int32 active_beam_width = 2 [default = 100];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_active_beam_width(), target);
  }

  // optional int32 prefix_beam_width = 3 [default = 3];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_prefix_beam_width(), target);
  }

  // optional int32 token_pool_capacity = 4 [default = 1000];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_token_pool_capacity(), target);
  }

  // optional int32 num_suggestions_to_return = 5 [default = 20];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_num_suggestions_to_return(), target);
  }

  // optional float score_to_beat_offset = 6 [default = -12];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_score_to_beat_offset(), target);
  }

  // optional float score_to_beat_offset_for_corrections = 7 [default = -6];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_score_to_beat_offset_for_corrections(), target);
  }

  // optional float prefix_lm_weight = 8 [default = 0.5];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_prefix_lm_weight(), target);
  }

  // optional float lexicon_unigram_backoff = 9 [default = -5];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_lexicon_unigram_backoff(), target);
  }

  // optional .proto.GestureSpatialParams gesture_params = 10;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::gesture_params(this), target, stream);
  }

  // optional .proto.TapSpatialParams tap_params = 11;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::tap_params(this), target, stream);
  }

  // optional int32 max_multi_term_terminals = 12 [default = 10];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_max_multi_term_terminals(), target);
  }

  // optional float score_to_beat_absolute = 13 [default = -inf];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(13, this->_internal_score_to_beat_absolute(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.DecoderParams)
  return target;
}

size_t DecoderParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.DecoderParams)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .proto.GestureSpatialParams gesture_params = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gesture_params_);
    }

    // optional .proto.TapSpatialParams tap_params = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tap_params_);
    }

    // optional float score_to_beat_absolute = 13 [default = -inf];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float sample_distance_in_key_widths = 1 [default = 0.25];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 active_beam_width = 2 [default = 100];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_active_beam_width());
    }

    // optional int32 prefix_beam_width = 3 [default = 3];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_prefix_beam_width());
    }

    // optional int32 token_pool_capacity = 4 [default = 1000];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_token_pool_capacity());
    }

    // optional int32 num_suggestions_to_return = 5 [default = 20];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_suggestions_to_return());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional float score_to_beat_offset = 6 [default = -12];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float score_to_beat_offset_for_corrections = 7 [default = -6];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float prefix_lm_weight = 8 [default = 0.5];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float lexicon_unigram_backoff = 9 [default = -5];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional int32 max_multi_term_terminals = 12 [default = 10];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_multi_term_terminals());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DecoderParams::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.DecoderParams)
  GOOGLE_DCHECK_NE(&from, this);
  const DecoderParams* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DecoderParams>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.DecoderParams)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.DecoderParams)
    MergeFrom(*source);
  }
}

void DecoderParams::MergeFrom(const DecoderParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.DecoderParams)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_gesture_params()->::proto::GestureSpatialParams::MergeFrom(from._internal_gesture_params());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_tap_params()->::proto::TapSpatialParams::MergeFrom(from._internal_tap_params());
    }
    if (cached_has_bits & 0x00000004u) {
      score_to_beat_absolute_ = from.score_to_beat_absolute_;
    }
    if (cached_has_bits & 0x00000008u) {
      sample_distance_in_key_widths_ = from.sample_distance_in_key_widths_;
    }
    if (cached_has_bits & 0x00000010u) {
      active_beam_width_ = from.active_beam_width_;
    }
    if (cached_has_bits & 0x00000020u) {
      prefix_beam_width_ = from.prefix_beam_width_;
    }
    if (cached_has_bits & 0x00000040u) {
      token_pool_capacity_ = from.token_pool_capacity_;
    }
    if (cached_has_bits & 0x00000080u) {
      num_suggestions_to_return_ = from.num_suggestions_to_return_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      score_to_beat_offset_ = from.score_to_beat_offset_;
    }
    if (cached_has_bits & 0x00000200u) {
      score_to_beat_offset_for_corrections_ = from.score_to_beat_offset_for_corrections_;
    }
    if (cached_has_bits & 0x00000400u) {
      prefix_lm_weight_ = from.prefix_lm_weight_;
    }
    if (cached_has_bits & 0x00000800u) {
      lexicon_unigram_backoff_ = from.lexicon_unigram_backoff_;
    }
    if (cached_has_bits & 0x00001000u) {
      max_multi_term_terminals_ = from.max_multi_term_terminals_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DecoderParams::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.DecoderParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DecoderParams::CopyFrom(const DecoderParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.DecoderParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecoderParams::IsInitialized() const {
  return true;
}

void DecoderParams::InternalSwap(DecoderParams* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DecoderParams, tap_params_)
      + sizeof(DecoderParams::tap_params_)
      - PROTOBUF_FIELD_OFFSET(DecoderParams, gesture_params_)>(
          reinterpret_cast<char*>(&gesture_params_),
          reinterpret_cast<char*>(&other->gesture_params_));
  swap(score_to_beat_absolute_, other->score_to_beat_absolute_);
  swap(sample_distance_in_key_widths_, other->sample_distance_in_key_widths_);
  swap(active_beam_width_, other->active_beam_width_);
  swap(prefix_beam_width_, other->prefix_beam_width_);
  swap(token_pool_capacity_, other->token_pool_capacity_);
  swap(num_suggestions_to_return_, other->num_suggestions_to_return_);
  swap(score_to_beat_offset_, other->score_to_beat_offset_);
  swap(score_to_beat_offset_for_corrections_, other->score_to_beat_offset_for_corrections_);
  swap(prefix_lm_weight_, other->prefix_lm_weight_);
  swap(lexicon_unigram_backoff_, other->lexicon_unigram_backoff_);
  swap(max_multi_term_terminals_, other->max_multi_term_terminals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DecoderParams::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::proto::GestureSpatialParams* Arena::CreateMaybeMessage< ::proto::GestureSpatialParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::GestureSpatialParams >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TapSpatialParams* Arena::CreateMaybeMessage< ::proto::TapSpatialParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TapSpatialParams >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::DecoderParams* Arena::CreateMaybeMessage< ::proto::DecoderParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::DecoderParams >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
