// Copyright 2005, 2006 Google Inc. All rights reserved
//
// State Table follower for scanning UTF-8 strings without converting to
// 32- or 16-bit Unicode values.
//
// See design document:
// https://g3doc.corp.google.com/util/utf8/public/g3doc/utf8_state_tables.md
//

#ifndef UTIL_UTF8_PUBLIC_UTF8STATETABLE_H_
#define UTIL_UTF8_PUBLIC_UTF8STATETABLE_H_

#include "integral_types.h"  // for uint8, uint32, uint16
#include "macros.h"          // for GOOGLE_DEPRECATED
#include "stringpiece.h"  // for StringPiece
#include "offsetmap.h"

// These four-byte entries compactly encode how many bytes 0..255 to delete
// in making a string replacement, how many bytes to add 0..255, and the offset
// 0..64k-1 of the replacement string in remap_string.
struct RemapEntry {
    uint8 delete_bytes;
    uint8 add_bytes;
    uint16 bytes_offset;
};

// Exit type codes for state tables. All but the first get stuffed into
// signed one-byte entries. The first is only generated by executable code.
// To distinguish from next-state entries, these must be contiguous and
// all <= kExitNone
typedef enum {
    kExitDstSpaceFull = 239,
    kExitIllegalStructure,  // 240
    kExitOK,                // 241
    kExitReject,            // ...
    kExitReplace1,
    kExitReplace2,
    kExitReplace3,
    kExitReplace21,
    kExitReplace31,
    kExitReplace32,
    kExitReplaceOffset1,
    kExitReplaceOffset2,
    kExitReplace1S0,
    kExitSpecial,
    kExitDoAgain,
    kExitRejectAlt,
    kExitNone               // 255
} ExitReason;

typedef enum {
    kExitDstSpaceFull_2 = 32767,       // 0x7fff
    kExitIllegalStructure_2,  // 32768    0x8000
    kExitOK_2,                // 32769    0x8001
    kExitReject_2,            // ...
    kExitReplace1_2,
    kExitReplace2_2,
    kExitReplace3_2,
    kExitReplace21_2,
    kExitReplace31_2,
    kExitReplace32_2,
    kExitReplaceOffset1_2,
    kExitReplaceOffset2_2,
    kExitReplace1S0_2,
    kExitSpecial_2,
    kExitDoAgain_2,
    kExitRejectAlt_2,
    kExitNone_2               // 32783    0x800f
} ExitReason_2;

#if 0
//------------------------------------------------------------------------------
// Old, signed version
typedef enum {
  kExitDstSpaceFull_2 = -32769,      // 0x7fff
  kExitIllegalStructure_2,  // -32768   0x8000
  kExitOK_2,                // -32767   0x8001
  kExitReject_2,            // ...
  kExitReplace1_2,
  kExitReplace2_2,
  kExitReplace3_2,
  kExitReplace21_2,
  kExitReplace31_2,
  kExitReplace32_2,
  kExitReplaceOffset1_2,
  kExitReplaceOffset2_2,
  kExitReplace1S0_2,
  kExitSpecial_2,
  kExitDoAgain_2,
  kExitRejectAlt_2,
  kExitNone_2               // -32753   0x800f
} ExitReason_2;
//------------------------------------------------------------------------------
#endif

// This struct represents one entire state table. The three initialized byte
// areas are state_table, remap_base, and remap_string. state0 and state0_size
// give the byte offset and length within state_table of the initial state --
// table lookups are expected to start and end in this state, but for
// truncated UTF-8 strings, may end in a different state. These allow a quick
// test for that condition. entry_shift is 8 for tables subscripted by a full
// byte value and 6 for space-optimized tables subscripted by only six
// significant bits in UTF-8 continuation bytes.
typedef struct {
    const uint32 state0;
    const uint32 state0_size;
    const uint32 total_size;
    const int max_expand;
    const int entry_shift;
    const int bytes_per_entry;
    const uint32 losub;
    const uint32 hiadd;
    const uint8* state_table;
    const RemapEntry* remap_base;
    const uint8* remap_string;
    const uint8* fast_state;
} UTF8StateMachineObj;

// Near-duplicate declaration for tables with two-byte entries
typedef struct {
    const uint32 state0;
    const uint32 state0_size;
    const uint32 total_size;
    const int max_expand;
    const int entry_shift;
    const int bytes_per_entry;
    const uint32 losub;
    const uint32 hiadd;
    const unsigned short* state_table;
    const RemapEntry* remap_base;
    const uint8* remap_string;
    const uint8* fast_state;
} UTF8StateMachineObj_2;


typedef UTF8StateMachineObj UTF8PropObj;
typedef UTF8StateMachineObj UTF8ScanObj;
typedef UTF8StateMachineObj UTF8ReplaceObj;
typedef UTF8StateMachineObj_2 UTF8PropObj_2;
typedef UTF8StateMachineObj_2 UTF8ReplaceObj_2;
typedef UTF8StateMachineObj_2 UTF8ScanObj_2;


// Look up property of one UTF-8 character and advance over it
// Return 0 if input length is zero
// Return 0 and advance one byte if input is ill-formed
uint8 UTF8GenericProperty(const UTF8PropObj* st,
                          const uint8** src,
                          int* src_len);

// Look up property of one UTF-8 character (assumed to be valid).
// (This is a faster version of UTF8GenericProperty.)
bool UTF8HasGenericProperty(const UTF8PropObj& st, const char* src);


// BigOneByte versions are needed for tables > 240 states, but most
// won't need the TwoByte versions.

// Look up property of one UTF-8 character and advance over it
// Return 0 if input length is zero
// Return 0 and advance one byte if input is ill-formed
uint8 UTF8GenericPropertyBigOneByte(const UTF8PropObj* st,
                                    const uint8** src,
                                    int* src_len);


// TwoByte versions are needed for tables > 240 states that don't fit onto
// BigOneByte -- rare ultimate fallback

// Look up property of one UTF-8 character (assumed to be valid).
// (This is a faster version of UTF8GenericProperty.)
bool UTF8HasGenericPropertyBigOneByte(const UTF8PropObj& st, const char* src);

// Look up property of one UTF-8 character and advance over it
// Return 0 if input length is zero
// Return 0 and advance one byte if input is ill-formed
uint8 UTF8GenericPropertyTwoByte(const UTF8PropObj_2* st,
                                 const uint8** src,
                                 int* src_len);

// Look up property of one UTF-8 character (assumed to be valid).
// (This is a faster version of UTF8GenericProperty.)
bool UTF8HasGenericPropertyTwoByte(const UTF8PropObj_2& st, const char* src);

// Scan a UTF-8 stringpiece based on a state table.
// Always scan complete UTF-8 characters
// Set number of bytes scanned. Return reason for exiting
int UTF8GenericScan(const UTF8ScanObj* st,
                    StringPiece str,
                    int* bytes_consumed);

// Scan a UTF-8 stringpiece based on a 2-byte state table.
// Always scan complete UTF-8 characters
// Set number of bytes scanned. Return reason for exiting.
// (A return value other than kExitOK indicates that the string
// was invalid starting at str[bytes_consumed].)
int UTF8GenericScanTwoByte(const UTF8ScanObj_2* st,
                           StringPiece str,
                           int* bytes_consumed);


// Scan a UTF-8 stringpiece based on a state table.
// Always scan complete UTF-8 characters
// Set number of bytes scanned. Return reason for exiting
// OPTIMIZED for case of 7-bit ASCII 0000..007f all valid
int UTF8GenericScanFastAscii(const UTF8ScanObj* st,
                             StringPiece str,
                             int* bytes_consumed);

// Returns initial number of bytes of structurally valid UTF-8.
// Surrogate codepoints are considered invalid.
int UTF8SpnStructurallyValid(StringPiece str);

inline int UTF8SpnStructurallyValidCharStar(const char* ch, int len) {
    return UTF8SpnStructurallyValid(StringPiece(ch, len));
}

// Wrapper that just gives true if all bytes are structurally valid UTF-8
inline bool UTF8IsStructurallyValid(StringPiece str) {
    return UTF8SpnStructurallyValid(str) == str.length();
}

// Coerces the byte string in str to be structurally-valid UTF-8 by
// copying str to dst, which must be at least as long as str.size()
// and then replacing all invalid bytes in dst with replace_char
// (typically ' ' or '?'). replace_char must be legal printable 7-bit
// Ascii 0x20..0x7e.
//
// Returns dst.
char* UTF8CoerceToStructurallyValid(StringPiece str,
                                    char* dst,
                                    const char replace_char);


// Wrapper that gives true if all bytes are valid ISO-8859-1
// NOTE: NOT Microsoft code page 1252; bytes 0x80-0x9f return false.
bool IsValidLatin1(StringPiece str);

// Alternate wrapper without StringPiece
bool IsValidLatin1CharStar(const char* ch, const int len);

// Scan a UTF-8 stringpiece based on state table, copying to output buffer
//   and doing text replacements.
// Always scan complete UTF-8 characters
// Set number of bytes consumed from input, number filled to output.
// Return reason for exiting
// Also writes an optional OffsetMap. Pass NULL (or omit the
// parameter) to skip writing one.
int UTF8GenericReplace(const UTF8ReplaceObj* st,
                       StringPiece str,
                       char* dst,
                       int dst_len,
                       bool is_plain_text,
                       int* bytes_consumed,
                       int* bytes_filled,
                       int* chars_changed,
                       OffsetMap* offsetmap = nullptr);


inline int UTF8GenericReplace(const UTF8ReplaceObj* st,
                              StringPiece istr,
                              StringPiece& ostr,
                              bool is_plain_text,
                              int* bytes_consumed,
                              int* bytes_filled,
                              int* chars_changed,
                              OffsetMap* offsetmap = nullptr) {
    return UTF8GenericReplace(st, istr, const_cast<char*>(ostr.data()),
                              ostr.size(), is_plain_text, bytes_consumed,
                              bytes_filled, chars_changed, offsetmap);
}


inline int UTF8GenericReplace(const UTF8ReplaceObj* st,
                              StringPiece istr,
                              StringPiece& ostr,
                              int* bytes_consumed,
                              int* bytes_filled,
                              int* chars_changed) {
    return UTF8GenericReplace(st, istr, const_cast<char*>(ostr.data()),
                              ostr.size(), /*is_plain_text=*/false,
                              bytes_consumed, bytes_filled, chars_changed);
}


// TwoByte version is needed for tables > about 256 states, such
// as the table for full Unicode 4.1 canonical + compatibility mapping

// Scan a UTF-8 stringpiece based on state table with two-byte entries,
//   copying to output stringpiece
//   and doing text replacements.
// Always scan complete UTF-8 characters
// Set number of bytes consumed from input, number filled to output.
// Return reason for exiting
// Also writes an optional OffsetMap. Pass NULL to skip writing one.
int UTF8GenericReplaceTwoByte(
        const UTF8ReplaceObj_2* st,
        StringPiece str,
        char* dst,
        int dst_len,
        bool is_plain_text,
        int* bytes_consumed,
        int* bytes_filled,
        int* chars_changed,
        OffsetMap* offsetmap = nullptr);

inline int UTF8GenericReplaceTwoByte(const UTF8ReplaceObj_2* st,
                                     StringPiece istr,
                                     StringPiece& ostr,
                                     bool is_plain_text,
                                     int* bytes_consumed,
                                     int* bytes_filled,
                                     int* chars_changed,
                                     OffsetMap* offsetmap = nullptr) {
    return UTF8GenericReplaceTwoByte(st, istr, const_cast<char*>(ostr.data()),
                                     ostr.size(), is_plain_text, bytes_consumed,
                                     bytes_filled, chars_changed, offsetmap);
}

inline int UTF8GenericReplaceTwoByte(const UTF8ReplaceObj_2* st,
                                     StringPiece istr,
                                     StringPiece& ostr,
                                     int* bytes_consumed,
                                     int* bytes_filled,
                                     int* chars_changed) {
    return UTF8GenericReplaceTwoByte(st, istr, const_cast<char*>(ostr.data()),
                                     ostr.size(), /*is_plain_text=*/false,
                                     bytes_consumed, bytes_filled, chars_changed);
}


static const unsigned char kUTF8LenTbl[256] = {
        1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,

        1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
        2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
        3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4, 4,4,4,4,4,4,4,4
};

inline int UTF8OneCharLen(const char* in) {
    return kUTF8LenTbl[*reinterpret_cast<const uint8*>(in)];
}


// Adjust a stringpiece to encompass complete UTF-8 characters.
// The data pointer will be increased by 0..3 bytes to get to a character
// boundary, and the length will then be decreased by 0..3 bytes
// to encompass the last complete character.
// This is useful especially when a UTF-8 string must be put into a fixed-
// maximum-size buffer cleanly, such as a MySQL buffer.
void UTF8TrimToChars(StringPiece* str);


#if 1
//----------------------------------------------------------------------
// EXPERIMENT
//
// Design center is 10-40 bytes of input
// Returns number of characters changed
//
// currently uses utf8cvtlowerorigja_obj table
int UTF8ToLowerShort(const char* src_buf,
                     int src_len,
                     string* output_buffer);
//----------------------------------------------------------------------
#endif

#endif  // UTIL_UTF8_PUBLIC_UTF8STATETABLE_H_
